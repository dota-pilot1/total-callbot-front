import { useState, useEffect, useRef } from "react";
import { useNavigate } from "react-router-dom";

import {
  ArrowLeftIcon,
  MicrophoneIcon,
  LanguageIcon,
  PaperAirplaneIcon,
  PlayIcon,
  StopIcon,
} from "@heroicons/react/24/outline";
import { examApi } from "../features/chatbot/exam/api/exam";
import { useAuthStore } from "../features/auth";
import { useVoiceToText } from "../features/conversation-archive/hooks/useVoiceToText";

// TypeScript declarations for Web Speech API
declare global {
  interface Window {
    SpeechRecognition?: any;
    webkitSpeechRecognition?: any;
  }
}

export default function Practice() {
  const navigate = useNavigate();

  const [koreanText, setKoreanText] = useState("");
  const [englishText, setEnglishText] = useState("");
  const [isTranslating, setIsTranslating] = useState(false);
  const [useRealtimeAPI, setUseRealtimeAPI] = useState(true);
  const [isWebSpeechListening, setIsWebSpeechListening] = useState(false);

  const [isSpeaking, setIsSpeaking] = useState(false);
  const [speakingText, setSpeakingText] = useState("");
  const recognitionRef = useRef<any>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);

  // Realtime API ÏùåÏÑ± Ïù∏Ïãù
  const {
    isRecording: isRealtimeRecording,
    isListening: isRealtimeListening,
    startRecording: startRealtimeRecording,
    stopRecording: stopRealtimeRecording,
  } = useVoiceToText({
    onTranscript: (text: string, isFinal: boolean) => {
      if (isFinal && text.trim()) {
        setKoreanText(text.trim());
      }
    },
    onError: (error: string) => {
      console.error("Realtime API Ïò§Î•ò:", error);
      alert(`ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò: ${error}`);
    },
  });

  // Web Speech API ÏßÄÏõê Ïó¨Î∂Ä ÌôïÏù∏
  const isWebSpeechSupported = Boolean(
    window.SpeechRecognition || window.webkitSpeechRecognition,
  );

  // Web Speech API ÏùåÏÑ± Ïù∏Ïãù (fallback)
  const startWebSpeechListening = () => {
    console.log("üé§ Web Speech API ÏãúÏûë");
    if (!isWebSpeechSupported) {
      alert("Ïù¥ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî Web Speech APIÍ∞Ä ÏßÄÏõêÎêòÏßÄ ÏïäÏäµÎãàÎã§.");
      return;
    }

    try {
      const SpeechRecognition =
        window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognition();

      // ÏïàÏ†ïÏÑ±ÏùÑ ÏúÑÌïú ÏÑ§Ï†ï Í∞úÏÑ†
      recognition.lang = "ko-KR";
      recognition.continuous = false; // Ïó∞ÏÜç Ïù∏Ïãù ÎπÑÌôúÏÑ±Ìôî (ÏïàÏ†ïÏÑ± Ìñ•ÏÉÅ)
      recognition.interimResults = false; // Ï§ëÍ∞Ñ Í≤∞Í≥º ÎπÑÌôúÏÑ±Ìôî (Î™ÖÌôïÌïú Í≤∞Í≥ºÎßå)
      recognition.maxAlternatives = 1;

      // ÌÉÄÏûÑÏïÑÏõÉ Î∞©ÏßÄ
      let hasResult = false;

      recognition.onstart = () => {
        setIsWebSpeechListening(true);
        console.log("üé§ Web Speech ÏùåÏÑ±Ïù∏Ïãù ÏãúÏûë");

        // 10Ï¥à ÌõÑ ÏûêÎèô Ï¢ÖÎ£å (ÌÉÄÏûÑÏïÑÏõÉ Î∞©ÏßÄ)
        setTimeout(() => {
          if (!hasResult && recognitionRef.current) {
            console.log("‚è∞ ÌÉÄÏûÑÏïÑÏõÉÏúºÎ°ú Ïù∏Ìïú ÏûêÎèô Ï¢ÖÎ£å");
            recognition.stop();
          }
        }, 10000);
      };

      recognition.onresult = (event: any) => {
        hasResult = true;
        const transcript = event.results[0][0].transcript;
        console.log("üé§ Web Speech ÏµúÏ¢Ö Í≤∞Í≥º:", transcript);
        setKoreanText((prev) =>
          prev ? `${prev} ${transcript.trim()}` : transcript.trim(),
        );
        setIsWebSpeechListening(false);
      };

      recognition.onerror = (event: any) => {
        console.error("Web Speech Ïò§Î•ò:", event.error);
        hasResult = true; // Ïò§Î•òÎèÑ Í≤∞Í≥ºÎ°ú Í∞ÑÏ£ºÌïòÏó¨ ÌÉÄÏûÑÏïÑÏõÉ Î∞©ÏßÄ

        let errorMessage = "ÏùåÏÑ± Ïù∏Ïãù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";
        switch (event.error) {
          case "no-speech":
            errorMessage = "ÏùåÏÑ±Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.";
            break;
          case "not-allowed":
            errorMessage =
              "ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑ºÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.";
            break;
          case "audio-capture":
            errorMessage =
              "ÎßàÏù¥ÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÎßàÏù¥ÌÅ¨Í∞Ä Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.";
            break;
          case "network":
            errorMessage =
              "ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Realtime APIÎ•º ÏÇ¨Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî.";
            break;
        }
        alert(errorMessage);
        setIsWebSpeechListening(false);
      };

      recognition.onend = () => {
        setIsWebSpeechListening(false);
        console.log("üé§ Web Speech ÏùåÏÑ±Ïù∏Ïãù Ï¢ÖÎ£å");
      };

      recognitionRef.current = recognition;
      recognition.start();
    } catch (error) {
      console.error("Web Speech Ï¥àÍ∏∞Ìôî Ïò§Î•ò:", error);
      setIsWebSpeechListening(false);
      alert("ÏùåÏÑ± Ïù∏ÏãùÏùÑ ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§. Realtime APIÎ•º ÏÇ¨Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî.");
    }
  };

  const stopWebSpeechListening = () => {
    if (recognitionRef.current) {
      recognitionRef.current.stop();
    }
    setIsWebSpeechListening(false);
  };

  // ÌÜµÌï© ÏùåÏÑ± Ïù∏Ïãù Ï†úÏñ¥
  const handleVoiceToggle = async () => {
    if (useRealtimeAPI) {
      if (isRealtimeRecording) {
        stopRealtimeRecording();
      } else {
        await startRealtimeRecording();
      }
    } else {
      if (isWebSpeechListening) {
        stopWebSpeechListening();
      } else {
        startWebSpeechListening();
      }
    }
  };

  const isCurrentlyListening = useRealtimeAPI
    ? isRealtimeRecording
    : isWebSpeechListening;
  const isDetectingVoice = useRealtimeAPI
    ? isRealtimeListening
    : isWebSpeechListening;

  const translateToEnglish = async () => {
    if (!koreanText.trim()) return;
    setIsTranslating(true);
    try {
      const prompt = `Please translate the following Korean text to English. Only provide the English translation, no additional text:

Korean: "${koreanText}"`;

      const response = await examApi.getSampleAnswers({
        question: prompt,
        topic: "translation",
        level: "intermediate",
        count: 1,
        englishOnly: true,
      });

      const translation = response.samples?.[0]?.text?.trim() || "";
      if (translation) {
        setEnglishText(translation);
      } else {
        setEnglishText(`[Translation failed] ${koreanText}`);
      }
    } catch (error) {
      console.error("Î≤àÏó≠ Ïò§Î•ò:", error);
      setEnglishText(`[Translation error] ${koreanText}`);
    } finally {
      setIsTranslating(false);
    }
  };

  // ÌïúÍ∏Ä ÏûÖÎ†•Ïù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ ÏûêÎèôÏúºÎ°ú ÏòÅÏñ¥ Î≤àÏó≠ (1Ï¥à ÎîîÎ∞îÏö¥Ïä§)
  useEffect(() => {
    const timer = setTimeout(() => {
      if (koreanText.trim() && koreanText.length > 2) {
        translateToEnglish();
      }
    }, 1000);

    return () => clearTimeout(timer);
  }, [koreanText]);

  // Ïñ∏Ïñ¥ Í∞êÏßÄ Ìï®Ïàò
  const detectLanguage = (text: string): "ko" | "en" => {
    const koreanRegex = /[„Ñ±-„Öé|„Öè-„Ö£|Í∞Ä-Ìû£]/;
    return koreanRegex.test(text) ? "ko" : "en";
  };

  // TTS Í∏∞Îä•
  const playText = async (text: string) => {
    if (!text.trim()) return;

    try {
      // Ïù¥Ï†Ñ Ïò§ÎîîÏò§ Ï§ëÏßÄ
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }

      setIsSpeaking(true);
      setSpeakingText(text);

      // Î∞±ÏóîÎìúÏóêÏÑú OpenAI API ÌÇ§ Î∞õÍ∏∞
      const token = useAuthStore.getState().getAccessToken();
      const apiUrl =
        window.location.hostname === "localhost"
          ? "/api/config/openai-key"
          : "https://api.total-callbot.cloud/api/config/openai-key";

      const keyResponse = await fetch(apiUrl, {
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
      });

      if (!keyResponse.ok) {
        throw new Error(`API ÏöîÏ≤≠ Ïã§Ìå®: ${keyResponse.status}`);
      }

      const { key } = await keyResponse.json();

      // Ïñ∏Ïñ¥ Í∞êÏßÄ
      const isKorean = detectLanguage(text) === "ko";

      // OpenAI TTS API ÏßÅÏ†ë Ìò∏Ï∂ú
      const ttsResponse = await fetch(
        "https://api.openai.com/v1/audio/speech",
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${key}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            model: "tts-1",
            input: text,
            voice: isKorean ? "nova" : "alloy",
            speed: 1.0,
          }),
        },
      );

      if (ttsResponse.ok) {
        const audioBlob = await ttsResponse.blob();

        // Data URL Î∞©ÏãùÏúºÎ°ú Î≥ÄÌôò (Î™®Î∞îÏùº Ìò∏ÌôòÏÑ±)
        const reader = new FileReader();
        reader.onload = async () => {
          audioRef.current = new Audio(reader.result as string);
          audioRef.current.onended = () => {
            setIsSpeaking(false);
            setSpeakingText("");
          };
          audioRef.current.onerror = () => {
            setIsSpeaking(false);
            setSpeakingText("");
            console.error("Audio playback failed");
          };
          await audioRef.current.play();
        };
        reader.onerror = () => {
          console.error("FileReader error");
          setIsSpeaking(false);
          setSpeakingText("");
        };
        reader.readAsDataURL(audioBlob);
      } else {
        throw new Error("TTS API ÏöîÏ≤≠ Ïã§Ìå®");
      }
    } catch (error) {
      console.error("TTS Ïò§Î•ò:", error);
      setIsSpeaking(false);
      setSpeakingText("");
      alert("ÏùåÏÑ± Ïû¨ÏÉùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
    }
  };

  const copyToClipboard = (text: string, type: string) => {
    if (!text.trim()) return;

    navigator.clipboard
      .writeText(text)
      .then(() => {
        alert(`${type} ÌÖçÏä§Ìä∏Í∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§.`);
      })
      .catch(() => {
        alert("ÌÅ¥Î¶ΩÎ≥¥Îìú Î≥µÏÇ¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      });
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      {/* Ìó§Îçî */}
      <div className="bg-white shadow-sm border-b border-gray-200 flex-shrink-0">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex items-center justify-between h-16">
            <div className="flex items-center space-x-3">
              <button
                onClick={() => navigate(-1)}
                className="w-10 h-10 rounded-full transition-colors flex items-center justify-center bg-gray-100 hover:bg-gray-200 text-gray-600"
                title="Îí§Î°úÍ∞ÄÍ∏∞"
              >
                <ArrowLeftIcon className="h-5 w-5" />
              </button>
              <h1 className="text-xl font-semibold text-gray-900">
                ÏùåÏÑ± ÏûÖÎ†• Ïó∞ÏäµÏû•
              </h1>
            </div>
          </div>
        </div>
      </div>

      {/* Î©îÏù∏ Ïª®ÌÖêÏ∏† */}
      <div className="flex-1 max-w-4xl mx-auto w-full p-4 space-y-6">
        {/* API ÏÑ†ÌÉù */}
        <div className="bg-white rounded-lg p-4 shadow-sm border border-gray-200">
          <h3 className="text-sm font-medium text-gray-700 mb-3">
            ÏùåÏÑ± Ïù∏Ïãù Î∞©Ïãù
          </h3>
          <div className="flex items-center gap-4">
            <label className="flex items-center">
              <input
                type="radio"
                checked={useRealtimeAPI}
                onChange={() => setUseRealtimeAPI(true)}
                className="mr-2"
              />
              <span className="text-sm">
                Realtime API
                <span className="text-gray-500">(ÏïàÏ†ïÏ†Å, Í≥†ÌíàÏßà)</span>
              </span>
            </label>
            <label className="flex items-center">
              <input
                type="radio"
                checked={!useRealtimeAPI}
                onChange={() => setUseRealtimeAPI(false)}
                disabled={!isWebSpeechSupported}
                className="mr-2"
              />
              <span
                className={`text-sm ${!isWebSpeechSupported ? "text-gray-400" : ""}`}
              >
                Web Speech API
                <span className="text-gray-500">(Î¨¥Î£å, Î∏åÎùºÏö∞Ï†Ä ÏùòÏ°¥)</span>
              </span>
            </label>
          </div>
        </div>

        {/* ÎßàÏù¥ÌÅ¨ Î≤ÑÌäº */}
        <div className="flex flex-col items-center space-y-4">
          <button
            onClick={handleVoiceToggle}
            disabled={!useRealtimeAPI && !isWebSpeechSupported}
            className={`w-20 h-20 rounded-full flex items-center justify-center transition-all duration-200 ${
              isCurrentlyListening
                ? "bg-red-500 hover:bg-red-600 text-white"
                : "bg-blue-500 hover:bg-blue-600 text-white"
            } ${isDetectingVoice ? "animate-pulse" : ""} ${
              !useRealtimeAPI && !isWebSpeechSupported
                ? "opacity-50 cursor-not-allowed"
                : ""
            }`}
            title={isCurrentlyListening ? "ÏùåÏÑ±Ïù∏Ïãù Ï§ëÏßÄ" : "ÏùåÏÑ±Ïù∏Ïãù ÏãúÏûë"}
          >
            {isCurrentlyListening ? (
              <StopIcon className="h-10 w-10" />
            ) : (
              <MicrophoneIcon className="h-10 w-10" />
            )}
          </button>
          <div className="text-center">
            <p className="text-sm text-gray-600">
              {!useRealtimeAPI && !isWebSpeechSupported
                ? "ÏùåÏÑ±Ïù∏ÏãùÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∏åÎùºÏö∞Ï†ÄÏûÖÎãàÎã§"
                : isCurrentlyListening
                  ? useRealtimeAPI
                    ? isDetectingVoice
                      ? "ÏùåÏÑ± Í∞êÏßÄ Ï§ë... (Realtime API)"
                      : "ÏùåÏÑ± ÎåÄÍ∏∞ Ï§ë... (Realtime API)"
                    : "ÎßêÏîÄÌï¥ Ï£ºÏÑ∏Ïöî... (Web Speech)"
                  : "ÎßàÏù¥ÌÅ¨Î•º ÎàåÎü¨ ÏùåÏÑ±ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"}
            </p>
            <p className="text-xs text-gray-500 mt-1">
              ÌòÑÏû¨ ÏÇ¨Ïö© Ï§ë: {useRealtimeAPI ? "Realtime API" : "Web Speech API"}
            </p>
          </div>
        </div>

        {/* ÌïúÍµ≠Ïñ¥ ÏûÖÎ†• */}
        <div className="bg-white rounded-lg p-6 shadow-sm border border-gray-200">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-medium text-gray-900">ÌïúÍµ≠Ïñ¥</h2>
            <div className="flex items-center space-x-2">
              <button
                onClick={() => playText(koreanText)}
                disabled={
                  !koreanText.trim() ||
                  (isSpeaking && speakingText === koreanText)
                }
                className="px-3 py-2 bg-green-500 text-white rounded-md text-sm hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center space-x-1"
                title="ÌïúÍµ≠Ïñ¥ ÏùåÏÑ± Ïû¨ÏÉù"
              >
                <PlayIcon className="h-4 w-4" />
                <span>Ïû¨ÏÉù</span>
              </button>
              <button
                onClick={() => copyToClipboard(koreanText, "ÌïúÍµ≠Ïñ¥")}
                disabled={!koreanText.trim()}
                className="px-3 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center space-x-1"
              >
                <PaperAirplaneIcon className="h-4 w-4" />
                <span>Î≥µÏÇ¨</span>
              </button>
            </div>
          </div>
          <textarea
            value={koreanText}
            onChange={(e) => setKoreanText(e.target.value)}
            placeholder="ÏùåÏÑ±ÏúºÎ°ú ÏûÖÎ†•ÎêòÍ±∞ÎÇò ÏßÅÏ†ë ÌÉÄÏù¥ÌïëÌïòÏÑ∏Ïöî"
            className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
            rows={6}
          />
        </div>

        {/* ÏòÅÏñ¥ ÏûÖÎ†• */}
        <div className="bg-white rounded-lg p-6 shadow-sm border border-gray-200">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-medium text-gray-900">
              English{" "}
              {isTranslating && (
                <span className="text-blue-500">(Î≤àÏó≠ Ï§ë...)</span>
              )}
            </h2>
            <div className="flex items-center space-x-2">
              <button
                onClick={() => playText(englishText)}
                disabled={
                  !englishText.trim() ||
                  (isSpeaking && speakingText === englishText)
                }
                className="px-3 py-2 bg-green-500 text-white rounded-md text-sm hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center space-x-1"
                title="ÏòÅÏñ¥ ÏùåÏÑ± Ïû¨ÏÉù"
              >
                <PlayIcon className="h-4 w-4" />
                <span>Ïû¨ÏÉù</span>
              </button>
              <button
                onClick={() => copyToClipboard(englishText, "ÏòÅÏñ¥")}
                disabled={!englishText.trim() || isTranslating}
                className="px-3 py-2 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center space-x-1"
              >
                <PaperAirplaneIcon className="h-4 w-4" />
                <span>Î≥µÏÇ¨</span>
              </button>
            </div>
          </div>
          <textarea
            value={englishText}
            onChange={(e) => setEnglishText(e.target.value)}
            placeholder="ÌïúÍ∏Ä ÏûÖÎ†• Ïãú ÏûêÎèôÏúºÎ°ú ÏòÅÏñ¥ Î≤àÏó≠Ïù¥ ÌëúÏãúÎê©ÎãàÎã§"
            className="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
            rows={6}
          />
          {koreanText.trim() && (
            <button
              onClick={translateToEnglish}
              disabled={isTranslating}
              className="w-full mt-4 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center space-x-2"
            >
              <LanguageIcon className="h-5 w-5" />
              <span>{isTranslating ? "Î≤àÏó≠ Ï§ë..." : "Îã§Ïãú Î≤àÏó≠"}</span>
            </button>
          )}
        </div>
      </div>
    </div>
  );
}
